# Bicicle lamp

## Poblem

Design the software to control a simple LED based bicycle lamp. There are 2 buttons on the lamp. Button 1 switches the lamp from off to on red. Pressing Button 1 a second time causes the lamp to flash red. Pressing button 1 a third time switches the lamp to off. Pressing button 2 toggles the colour of the lamp from red to white or white to red.


### Assumptions

Assumption 1 – Lamp is Off to start with!
Assumption 2 – pressing button 2 while lamp is off has no effect!
Assumption 3: LED driver has the following APIs: redOn(), RedFlash(), ledOff(), whiteOn(), WhiteFlash()


## Approach

Taking into account that the solution must be implemented in a phisical small factor, the apparent simplicity of the software to be implemented and the interaction with electronic sensors (2 buttons) and actuators (a LED), I consider that the best platform over to implement the solution to the problem is a microcontroller. The code is at first simple and doesn't require multithreading, so an 8-bit microcontroller will be the best option, because of being the cheapest option able to do the job.

Between the microcontrollers available in the market, the Amtel Atmega328 has been chosen, for being a mature, cheap microcontroller relatively easy to work with. For the prototype it has been used an Arduino Uno development board, the most famous development board using the cited microcontroller, for the physical availability of two of them for inmediate prototyping.

As programming language, C++11 has been used, for being the standard programming language for Amtel Atmega328 microcontrollers. Besides, C++ is nowadays the most common language for microcontroller programming, so the use of C++ facilitates an hypotetical port to another microcontroller. For the same reason, I have decided to implement directly the main() function, instead of delegate main() implementation in teh autogenerated main() function using the implemented setup() and loop() functions, as it is done in Arduino IDE.

The development IDE used has been Visual Studio Code with the Platform.io extension, a popular extension for embedded microcontroller programming which provides support for many microcontrollers and provides advanced features for improving software development cycle, such as the support of unit testing through Unity testing framework. 


## Software architecture
Taking into account the finite number of states in which the bike lamp can be and the definition of clear transitions between states in the problem statement, I consider that the best approach will be to base the business logic of the software on the implementation of a Finite State Machine (FSM). The FSM diagram of the state machine implemented is shown here:

![alt text](https://github.com/adrianrejas/bicycle_lamp/blob/master/Bicycle_lamp_FSM.png?raw=true)

Here we can see that 6 states have been set, with each state being related with each of the the actions able to do through the LED driver. The implementation of these states is basically call to LED driver corresponding API function.

The only exception is with the states LED_RED_OFF and LED_WHITE_OFF, having the same implementation (call to ledOff() LED driver API function) and representing basically the same (the LED in off state). The reason for having separated these two states is because, according to the problem statement, at off state the software has to memorize in some way the state which comes next to off state (RED_ON or WHITE_ON). And the next step will depend of the previous state (RED_FLASH or WHITE_FLASH). In order not to consume additional memory for recording that info and keeping FSM as pure as possible, I consider the best approach is to divide off state into RED_OFF and WHITE_OFF.

The Amtel Atmega328 microcontroller only has one thread pipeline (enough for the problem), and the code executed in it is defined in the main() function of the main.cpp file. The flow diagram showing the working of the main() function is shown here:

![alt text](https://github.com/adrianrejas/bicycle_lamp/blob/master/Bicycle_lamp_flow_diagram.png?raw=true)

The main function, as standard in microcontroller programming, is divided into an initialization block for configuring the microcontroller hardware and other initialization statements and an endless loop managing business logic. 

The intialization block, appart from configuring the hardware in a basic way, instantiates the FSM defined previously and the LED driver to be used (setting the pins used by the LED peripheral). Additially, it configures the pins required for reading the actions of the two buttons. For detecting a button being pressed, there are three traditional ways to do that:
- Make a periodical polling of the state of the button in the endless loop of the main thread.
- Configure the microcontroller IRQ (Interrupt ReQuest) vector table for triggering an interrupt when a signal is received at the pin connected to the button. the ISR (Interrupt Service Routine) trigrerred can either deal with the full application of the logic imposed by the action or divide the application of this logic into two blocks: a top-half ISR (the proper ISR, which only set a variable used as a semaphore for triggering future tasks to be done) and a bottom-half ISR (a block defined into the main thread endless loop in the case of the microcontrollers, and awaken by the semaphore variable set by the top-half ISR). In the last case, the bottom-half ISR deals with the heavy tasks regarding the ISR logic.
Polling has two main drawbacks: the latency between the pression and the execution of the associated logic is bigger than with the use of interruptions and short pressions of the button can be missed if the main thread is busy at this moment, something that won't happend with the use of interruptions. Besides, the action to do when a button is pressed is to update the FSM, which involves tasks which can be a bit heavy for a pure ISR, like digita write on pins. Because all of this, the approach chosen has been the use of topt-half/bottom-half ISRs for managing the functions.

The relationships between the classes used in the code is show here:

![alt text](https://github.com/adrianrejas/bicycle_lamp/blob/master/Bicycle_lamp_code_architecture.png?raw=true)

I have based the architecture of the software on a main.cpp file, having the main() function implementation and the logic regarding the configuration and management of the interruptions related with the 2 buttons, and three classes:
- LedDriver: Abstract class representing a generic interface for any physical LED peripheral. If more than one LED peripherals have to be supported in the future, it will be enough with having several implementations of this interface, one for eacho of the LED peripherals supported.
- LedDriverImpl: Implementation of LedDriver currently used, based on the use of F51BW9RGB 4-pin LED and the use of Timer1 periodical interruptions in the Amtel Atmega328. It is implemented as a singleton because only one ISR can be assuciated with the Timer1 periodical interruptions. The main() function instantiates this class and passes it to the class representing the FSM.
- FSMBikeLamp: Class containing the business logic of the bicycle lamp FSM. It is instantiated by the main() function, receiving at initialization a reference to a LedDriver instance in order to manage the FSM business Logic related to the LED. When an button-related ISR is trigerred, the updateState() function of this class is called, setting the new state according to the current state and the action received, and calling the code required to be executed for the new state.

The source code is organized in the following 4 folders:
- src: Includes the main.cpp files with the main() function implementation.
- include: Includes a main.h header file with definitions of the pins used for interacting with the LED and the buttons.
- lib: Incudes the headers and source files regarding the classes LedDriver, LedDriverImpl and FSMBikeLam. Included here and not in src and include folders in order to be accessible from test cases defined in test folder.
- test: Includes definitions of test cases to be executed over the microcontroller hardware.


## Code Quality

In oder to assure the quality of the code as far as possible, the following steps have been followed:
- Application of known best practices in microcontroller development able to be applied on the code.
- Refactorization of the code in order to remove all warnings generated at compilation time.

Appart, a set of test cases have been developed in order to assure the reliability of the code in an automated way, with the possibility of including the execution of these test cases in a future CI/CD pipeline. The test cases included have been the following:
- test_FSMBikeLam: Unitary test case including a series of tests for checking the implementation of the business logic related with the FSM, including the check of the status of the LED by using a mock implementation. There are 13 test, one for checking the initial status of the FSM and the other 12 for checking the 12 possible transitions in the FSM.
- test_LedDriverImpl: Integration test case including a series of tests for checking the proper working of the LedDriverImpl used, by using 3 pins of the microcontroller for reading the status of the three data pins of the RGB led. There are 5 tests, one for each of the LED states possible, and they are repeated twice per test case execution.

Here the report of the last execution of both test cases can be found:
https://github.com/adrianrejas/bicycle_lamp/blob/master/Test_Cases_Execution.latest.txt


## Schematic

Two electronical circuits have been mounted for this project: the prototype and the test bench.

The prototype has been implemented in order to get a first prototype of the bicycle lamp. The schematic can be found here:

![alt text](https://github.com/adrianrejas/bicycle_lamp/blob/master/prototype_schematic.png?raw=true)

The list of materials used is the following:
- 1 Arduino Uno Rev.3 development board.
- 1 prototyping Arduino shield.
- 1 F51BW9RGB 4-pin LED.
- 2 Schuster 4-pin tactile switch.
- 2 4.7KOhm resistors.
- 6 AA batteries.
- Cables.

A picture of the prototype mounted can be found here:

![alt text](https://github.com/adrianrejas/bicycle_lamp/blob/master/prototype_mounted.png?raw=true)

The test bench has been implemented in order to get an execution platform for the test cases. The schematic can be found here:

![alt text](https://github.com/adrianrejas/bicycle_lamp/blob/master/test_schematic.png?raw=true)

The list of materials used is the following:
- 1 Arduino Uno Rev.3 development board.
- 1 breadboard.
- 1 F51BW9RGB 4-pin LED.
- 1 USB-to-Arduino cable.
- Cables.

A picture of the prototype mounted can be found here:

![alt text](https://github.com/adrianrejas/bicycle_lamp/blob/master/testbench_mounted.png?raw=true)

